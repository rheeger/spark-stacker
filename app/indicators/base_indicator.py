import abc
from enum import Enum
from typing import Dict, Any, List, Optional, Tuple, Union
import pandas as pd
import numpy as np


class SignalDirection(str, Enum):
    """Possible signal directions."""
    BUY = "BUY"
    SELL = "SELL"
    NEUTRAL = "NEUTRAL"


class Signal:
    """
    Represents a trading signal generated by an indicator.
    
    Attributes:
        direction: The signal direction (BUY, SELL, NEUTRAL)
        symbol: The market symbol (e.g., 'ETH')
        indicator: The name of the indicator that generated the signal
        confidence: A value between 0 and 1 indicating the confidence in the signal
        timestamp: The timestamp when the signal was generated
        params: Additional parameters specific to the signal
    """
    
    def __init__(
        self,
        direction: SignalDirection,
        symbol: str,
        indicator: str,
        confidence: float = 0.5,
        timestamp: Optional[int] = None,
        params: Optional[Dict[str, Any]] = None
    ):
        """
        Initialize a new Signal.
        
        Args:
            direction: The signal direction (BUY, SELL, NEUTRAL)
            symbol: The market symbol (e.g., 'ETH')
            indicator: The name of the indicator that generated the signal
            confidence: A value between 0 and 1 indicating the confidence in the signal
            timestamp: The timestamp when the signal was generated (milliseconds since epoch)
            params: Additional parameters specific to the signal
        """
        self.direction = direction
        self.symbol = symbol
        self.indicator = indicator
        self.confidence = min(max(confidence, 0), 1)  # Clamp between 0 and 1
        
        import time
        self.timestamp = timestamp or int(time.time() * 1000)
        self.params = params or {}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert the signal to a dictionary."""
        return {
            "direction": self.direction,
            "symbol": self.symbol,
            "indicator": self.indicator,
            "confidence": self.confidence,
            "timestamp": self.timestamp,
            "params": self.params
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Signal':
        """Create a Signal from a dictionary."""
        return cls(
            direction=SignalDirection(data["direction"]),
            symbol=data["symbol"],
            indicator=data["indicator"],
            confidence=data.get("confidence", 0.5),
            timestamp=data.get("timestamp"),
            params=data.get("params", {})
        )
    
    def __str__(self) -> str:
        """String representation of the signal."""
        return (
            f"Signal({self.direction.value}, {self.symbol}, {self.indicator}, "
            f"confidence={self.confidence:.2f}, timestamp={self.timestamp})"
        )


class BaseIndicator(abc.ABC):
    """
    Abstract base class for all technical indicators.
    
    This class defines the interface that all indicator implementations must follow.
    """
    
    def __init__(self, name: str, params: Optional[Dict[str, Any]] = None):
        """
        Initialize a new indicator.
        
        Args:
            name: The name of the indicator
            params: Configuration parameters for the indicator
        """
        self.name = name
        self.params = params or {}
    
    @abc.abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate the indicator values for the provided price data.
        
        Args:
            data: Price data as a pandas DataFrame with at least 'timestamp', 'open', 'high', 'low', 'close', 'volume' columns
            
        Returns:
            DataFrame with indicator values added as new columns
        """
        pass
    
    @abc.abstractmethod
    def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        """
        Generate a trading signal based on the indicator values.
        
        Args:
            data: Price data with indicator values (output from calculate())
            
        Returns:
            A Signal object if a signal is generated, None otherwise
        """
        pass
    
    def process(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Optional[Signal]]:
        """
        Process price data and generate a signal if conditions are met.
        
        This method combines calculate() and generate_signal().
        
        Args:
            data: Price data as a pandas DataFrame
            
        Returns:
            Tuple of (processed_data, signal)
        """
        processed_data = self.calculate(data)
        signal = self.generate_signal(processed_data)
        return processed_data, signal 