import abc
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Union

import numpy as np
import pandas as pd


class SignalDirection(str, Enum):
    """Possible signal directions."""

    BUY = "BUY"
    SELL = "SELL"
    NEUTRAL = "NEUTRAL"


class Signal:
    """
    Represents a trading signal generated by an indicator.

    Attributes:
        direction: The signal direction (BUY, SELL, NEUTRAL)
        symbol: The market symbol (e.g., 'ETH')
        indicator: The name of the indicator that generated the signal
        confidence: A value between 0 and 1 indicating the confidence in the signal
        timestamp: The timestamp when the signal was generated
        params: Additional parameters specific to the signal
    """

    def __init__(
        self,
        direction: SignalDirection,
        symbol: str,
        indicator: str,
        confidence: float = 0.5,
        timestamp: Optional[int] = None,
        params: Optional[Dict[str, Any]] = None,
    ):
        """
        Initialize a new Signal.

        Args:
            direction: The signal direction (BUY, SELL, NEUTRAL)
            symbol: The market symbol (e.g., 'ETH')
            indicator: The name of the indicator that generated the signal
            confidence: A value between 0 and 1 indicating the confidence in the signal
            timestamp: The timestamp when the signal was generated (milliseconds since epoch)
            params: Additional parameters specific to the signal
        """
        self.direction = direction
        self.symbol = symbol
        self.indicator = indicator
        self.confidence = min(max(confidence, 0), 1)  # Clamp between 0 and 1

        import time

        self.timestamp = timestamp or int(time.time() * 1000)
        self.params = params or {}

    def to_dict(self) -> Dict[str, Any]:
        """Convert the signal to a dictionary."""
        return {
            "direction": self.direction,
            "symbol": self.symbol,
            "indicator": self.indicator,
            "confidence": self.confidence,
            "timestamp": self.timestamp,
            "params": self.params,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "Signal":
        """Create a Signal from a dictionary."""
        return cls(
            direction=SignalDirection(data["direction"]),
            symbol=data["symbol"],
            indicator=data["indicator"],
            confidence=data.get("confidence", 0.5),
            timestamp=data.get("timestamp"),
            params=data.get("params", {}),
        )

    def __str__(self) -> str:
        """String representation of the signal."""
        return (
            f"Signal({self.direction.value}, {self.symbol}, {self.indicator}, "
            f"confidence={self.confidence:.2f}, timestamp={self.timestamp})"
        )


class BaseIndicator(abc.ABC):
    """
    Abstract base class for all technical indicators.

    This class defines the interface that all indicator implementations must follow.
    """

    def __init__(self, name: str, params: Optional[Dict[str, Any]] = None):
        """
        Initialize a new indicator.

        Args:
            name: The name of the indicator
            params: Configuration parameters for the indicator
        """
        self.name = name
        self.params = params or {}

        # Set timeframe attributes with fallbacks
        # Priority: explicit timeframe > interval > default to '1h'
        self.timeframe = self.params.get('timeframe', '1h')
        self.interval = self.params.get('interval', self.timeframe)

        # For backward compatibility, ensure both attributes are available
        if 'timeframe' in self.params and 'interval' not in self.params:
            self.interval = self.timeframe
        elif 'interval' in self.params and 'timeframe' not in self.params:
            self.timeframe = self.interval

    def get_effective_timeframe(self) -> str:
        """
        Get the effective timeframe for this indicator.

        Returns:
            The timeframe string (e.g., '1m', '1h', '4h', '1d')
        """
        return getattr(self, 'timeframe', getattr(self, 'interval', '1h'))

    def set_timeframe(self, timeframe: str) -> None:
        """
        Set the timeframe for this indicator.

        Args:
            timeframe: Timeframe string (e.g., '1m', '1h', '4h', '1d')
        """
        self.timeframe = timeframe
        self.interval = timeframe  # Keep interval in sync for backward compatibility

    @abc.abstractmethod
    def calculate(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate the indicator values for the provided price data.

        Args:
            data: Price data as a pandas DataFrame with at least 'timestamp', 'open', 'high', 'low', 'close', 'volume' columns

        Returns:
            DataFrame with indicator values added as new columns
        """
        pass

    @abc.abstractmethod
    def generate_signal(self, data: pd.DataFrame) -> Optional[Signal]:
        """
        Generate a trading signal based on the indicator values.

        Args:
            data: Price data with indicator values (output from calculate())

        Returns:
            A Signal object if a signal is generated, None otherwise
        """
        pass

    def process(self, data: pd.DataFrame) -> Tuple[pd.DataFrame, Optional[Signal]]:
        """
        Process price data and generate a signal if conditions are met.

        This method combines calculate() and generate_signal().

        Args:
            data: Price data as a pandas DataFrame

        Returns:
            Tuple of (processed_data, signal)
        """
        processed_data = self.calculate(data)
        signal = self.generate_signal(processed_data)
        return processed_data, signal

    def __str__(self) -> str:
        """String representation of the indicator."""
        return f"{self.__class__.__name__}(name={self.name}, timeframe={self.get_effective_timeframe()})"
