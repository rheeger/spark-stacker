"""
Metrics collection for the Spark Stacker trading application.

This module defines all the metrics that are collected and exposed to Prometheus.
"""

import time

from prometheus_client import Counter, Gauge, Histogram

# Application start time for uptime calculation
_START_TIME = time.time()

# System uptime and health metrics
uptime_seconds = Gauge(
    "spark_stacker_uptime_seconds",
    "Application uptime in seconds",
)


# Update uptime on each access
def _update_uptime():
    uptime_seconds.set(time.time() - _START_TIME)


# Trade metrics
trades_total = Counter(
    "spark_stacker_trades_total",
    "Total number of trades executed",
    ["result", "exchange", "side"],
)

# Position metrics
active_positions = Gauge(
    "spark_stacker_active_positions",
    "Number of currently active positions",
    ["exchange", "market", "side"],
)

# Signal metrics
signal_count = Counter(
    "spark_stacker_signal_count",
    "Number of signals generated by indicators",
    ["indicator", "signal"],
)

# API metrics
api_requests_total = Counter(
    "spark_stacker_api_requests_total",
    "Total number of API requests made",
    ["exchange", "endpoint", "method"],
)

api_latency_seconds = Histogram(
    "spark_stacker_api_latency_seconds",
    "API request latency in seconds",
    ["exchange", "endpoint"],
    buckets=(
        0.001,
        0.005,
        0.01,
        0.025,
        0.05,
        0.075,
        0.1,
        0.25,
        0.5,
        0.75,
        1.0,
        2.5,
        5.0,
        7.5,
        10.0,
        float("inf"),
    ),
)

order_execution_seconds = Histogram(
    "spark_stacker_order_execution_seconds",
    "Order execution time in seconds",
    ["exchange", "order_type"],
    buckets=(0.01, 0.05, 0.1, 0.5, 1.0, 2.5, 5.0, 10.0, float("inf")),
)

rate_limit_remaining = Gauge(
    "spark_stacker_rate_limit_remaining",
    "Number of API requests remaining before rate limit",
    ["exchange", "endpoint"],
)

# Risk metrics
margin_ratio = Gauge(
    "spark_stacker_margin_ratio",
    "Current margin ratio for positions",
    ["exchange", "position_id"],
)

liquidation_price = Gauge(
    "spark_stacker_liquidation_price",
    "Liquidation price for positions",
    ["exchange", "position_id"],
)

capital_utilization_percent = Gauge(
    "spark_stacker_capital_utilization_percent",
    "Percentage of capital currently in use",
)

max_drawdown_percent = Gauge(
    "spark_stacker_max_drawdown_percent", "Maximum drawdown percentage", ["timeframe"]
)

# Performance metrics
pnl_percent = Gauge(
    "spark_stacker_pnl_percent",
    "Profit and loss percentage",
    ["strategy", "position_type"],
)


# Helper functions for common metric operations
def record_trade(result: str, exchange: str, side: str) -> None:
    """
    Record a trade execution.

    Args:
        result: 'success' or 'failure'
        exchange: The exchange name
        side: 'buy' or 'sell'
    """
    trades_total.labels(result=result, exchange=exchange, side=side).inc()
    _update_uptime()


def update_position(exchange: str, market: str, side: str, count: int) -> None:
    """
    Update the count of active positions.

    Args:
        exchange: The exchange name
        market: The market symbol
        side: 'long' or 'short'
        count: The current count of positions
    """
    active_positions.labels(exchange=exchange, market=market, side=side).set(count)
    _update_uptime()


def record_signal(indicator: str, signal: str) -> None:
    """
    Record a signal generated by an indicator.

    Args:
        indicator: The name of the indicator
        signal: 'buy', 'sell', or 'neutral'
    """
    signal_count.labels(indicator=indicator, signal=signal).inc()
    _update_uptime()


def record_api_request(exchange: str, endpoint: str, method: str) -> None:
    """
    Record an API request.

    Args:
        exchange: The exchange name
        endpoint: The API endpoint path
        method: The HTTP method ('GET', 'POST', etc.)
    """
    api_requests_total.labels(exchange=exchange, endpoint=endpoint, method=method).inc()
    _update_uptime()


def observe_api_latency(exchange: str, endpoint: str, seconds: float) -> None:
    """
    Record the latency of an API request.

    Args:
        exchange: The exchange name
        endpoint: The API endpoint path
        seconds: The request duration in seconds
    """
    api_latency_seconds.labels(exchange=exchange, endpoint=endpoint).observe(seconds)
    _update_uptime()
