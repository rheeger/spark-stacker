#!/usr/bin/env python3
"""
Simplified demonstration of the indicator integration framework.

This script demonstrates:
1. Loading indicator configurations from YAML/JSON
2. Creating indicator instances
3. Calculating indicator values on sample data
4. Generating indicator signals
5. Comparing indicators
"""

import json
import logging
import os
import shutil
from datetime import datetime
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import yaml

# Configure logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)


class SignalDirection:
    """Possible signal directions."""
    BUY = "BUY"
    SELL = "SELL"
    NEUTRAL = "NEUTRAL"


class Signal:
    """Represents a trading signal generated by an indicator."""

    def __init__(
        self,
        direction,
        symbol,
        indicator,
        confidence=0.5,
        timestamp=None,
        params=None
    ):
        self.direction = direction
        self.symbol = symbol
        self.indicator = indicator
        self.confidence = min(max(confidence, 0), 1)

        if timestamp is None:
            import time
            timestamp = int(time.time() * 1000)

        self.timestamp = timestamp
        self.params = params or {}

    def to_dict(self):
        """Convert the signal to a dictionary."""
        return {
            "direction": self.direction,
            "symbol": self.symbol,
            "indicator": self.indicator,
            "confidence": self.confidence,
            "timestamp": self.timestamp,
            "params": self.params,
        }


class BaseIndicator:
    """Base class for all indicators."""

    def __init__(self, name, params=None):
        self.name = name
        self.params = params or {}

    def calculate(self, data):
        """Calculate indicator values. To be implemented by subclasses."""
        raise NotImplementedError("Subclasses must implement this method")

    def generate_signal(self, data):
        """Generate trading signal. To be implemented by subclasses."""
        raise NotImplementedError("Subclasses must implement this method")


class MAIndicator(BaseIndicator):
    """
    Moving Average indicator implementation.
    """

    def __init__(self, name="ma", params=None):
        super().__init__(name, params or {})
        self.short_period = self.params.get("short_period", 10)
        self.long_period = self.params.get("long_period", 50)
        self.ma_type = self.params.get("ma_type", "sma")  # 'sma' or 'ema'

    def calculate(self, data):
        """Calculate moving averages."""
        df = data.copy()

        # Calculate short MA
        if self.ma_type == "ema":
            df["short_ma"] = df["close"].ewm(span=self.short_period).mean()
            df["long_ma"] = df["close"].ewm(span=self.long_period).mean()
        else:  # Default to SMA
            df["short_ma"] = df["close"].rolling(window=self.short_period).mean()
            df["long_ma"] = df["close"].rolling(window=self.long_period).mean()

        # Calculate crossovers
        df["golden_cross"] = (
            (df["short_ma"] > df["long_ma"]) &
            (df["short_ma"].shift(1) <= df["long_ma"].shift(1))
        )

        df["death_cross"] = (
            (df["short_ma"] < df["long_ma"]) &
            (df["short_ma"].shift(1) >= df["long_ma"].shift(1))
        )

        return df

    def generate_signal(self, data):
        """Generate trading signals based on MA crossovers."""
        if len(data) < self.long_period:
            return None

        df = self.calculate(data)
        latest = df.iloc[-1]
        symbol = latest.get("symbol", "UNKNOWN")

        # Check for crossover signals
        if latest.get("golden_cross", False):
            return Signal(
                direction=SignalDirection.BUY,
                symbol=symbol,
                indicator=self.name,
                confidence=0.7,
                params={
                    "short_ma": latest["short_ma"],
                    "long_ma": latest["long_ma"],
                    "trigger": "golden_cross"
                }
            )
        elif latest.get("death_cross", False):
            return Signal(
                direction=SignalDirection.SELL,
                symbol=symbol,
                indicator=self.name,
                confidence=0.7,
                params={
                    "short_ma": latest["short_ma"],
                    "long_ma": latest["long_ma"],
                    "trigger": "death_cross"
                }
            )

        return None


class RSIIndicator(BaseIndicator):
    """
    Relative Strength Index indicator implementation.
    """

    def __init__(self, name="rsi", params=None):
        super().__init__(name, params or {})
        self.period = self.params.get("period", 14)
        self.overbought = self.params.get("overbought", 70)
        self.oversold = self.params.get("oversold", 30)

    def calculate(self, data):
        """Calculate RSI values."""
        df = data.copy()

        # Calculate price changes
        delta = df["close"].diff()

        # Get gains and losses
        gain = delta.copy()
        loss = delta.copy()
        gain[gain < 0] = 0
        loss[loss > 0] = 0
        loss = -loss  # Make losses positive

        # Calculate average gain and loss
        avg_gain = gain.rolling(window=self.period).mean()
        avg_loss = loss.rolling(window=self.period).mean()

        # Calculate RS and RSI
        rs = avg_gain / avg_loss
        df["rsi"] = 100 - (100 / (1 + rs))

        # Generate overbought/oversold signals
        df["overbought"] = df["rsi"] > self.overbought
        df["oversold"] = df["rsi"] < self.oversold

        # Crossing signals
        df["crosses_above_oversold"] = (
            (df["rsi"] > self.oversold) &
            (df["rsi"].shift(1) <= self.oversold)
        )

        df["crosses_below_overbought"] = (
            (df["rsi"] < self.overbought) &
            (df["rsi"].shift(1) >= self.overbought)
        )

        return df

    def generate_signal(self, data):
        """Generate trading signals based on RSI."""
        if len(data) < self.period:
            return None

        df = self.calculate(data)
        latest = df.iloc[-1]
        symbol = latest.get("symbol", "UNKNOWN")

        # Check for signals
        if latest.get("crosses_above_oversold", False):
            return Signal(
                direction=SignalDirection.BUY,
                symbol=symbol,
                indicator=self.name,
                confidence=0.6,
                params={
                    "rsi": latest["rsi"],
                    "trigger": "crosses_above_oversold"
                }
            )
        elif latest.get("crosses_below_overbought", False):
            return Signal(
                direction=SignalDirection.SELL,
                symbol=symbol,
                indicator=self.name,
                confidence=0.6,
                params={
                    "rsi": latest["rsi"],
                    "trigger": "crosses_below_overbought"
                }
            )

        return None


class IndicatorFactory:
    """Factory for creating indicator instances."""

    _indicator_registry = {
        "ma": MAIndicator,
        "rsi": RSIIndicator,
    }

    @classmethod
    def create_indicator(cls, name, indicator_type, params=None):
        """Create a new indicator instance."""
        if indicator_type not in cls._indicator_registry:
            logger.error(f"Indicator type '{indicator_type}' not supported")
            return None

        try:
            indicator_class = cls._indicator_registry[indicator_type]
            return indicator_class(name=name, params=params)
        except Exception as e:
            logger.error(f"Failed to create indicator: {e}")
            return None

    @classmethod
    def create_indicators_from_config(cls, configs):
        """Create multiple indicators from configurations."""
        indicators = {}

        for config in configs:
            name = config.get("name")
            indicator_type = config.get("type")
            enabled = config.get("enabled", True)
            params = config.get("parameters", {})

            if not name or not indicator_type:
                logger.warning("Skipping invalid indicator config")
                continue

            if not enabled:
                logger.info(f"Skipping disabled indicator: {name}")
                continue

            indicator = cls.create_indicator(
                name=name,
                indicator_type=indicator_type,
                params=params
            )

            if indicator:
                indicators[name] = indicator
                logger.info(f"Created indicator: {name} ({indicator_type})")

        return indicators

    @classmethod
    def get_available_indicators(cls):
        """Get list of available indicator types."""
        return list(cls._indicator_registry.keys())


class IndicatorConfigLoader:
    """Loads indicator configurations from files."""

    @staticmethod
    def load_from_file(config_path):
        """Load indicator configurations from a file."""
        try:
            with open(config_path, "r") as file:
                if str(config_path).endswith(".json"):
                    config_data = json.load(file)
                elif str(config_path).endswith((".yaml", ".yml")):
                    config_data = yaml.safe_load(file)
                else:
                    raise ValueError(f"Unsupported file format: {config_path}")

            # Check if it's a list or dict with 'indicators' key
            if isinstance(config_data, dict) and "indicators" in config_data:
                config_data = config_data["indicators"]

            if not isinstance(config_data, list):
                raise ValueError("Configuration must be a list of indicator configs")

            return config_data

        except Exception as e:
            logger.error(f"Error loading configuration from {config_path}: {e}")
            return []

    @classmethod
    def load_indicators(cls, config_path):
        """Load configurations and create indicator instances."""
        configs = cls.load_from_file(config_path)
        return IndicatorFactory.create_indicators_from_config(configs)


def generate_sample_data(length=500, symbol="BTC"):
    """Generate sample price data for demonstration."""
    # Create a date range
    dates = pd.date_range(start='2023-01-01', periods=length, freq='H')

    # Create initial price
    np.random.seed(42)
    base_price = 25000.0

    # Generate price movements with some patterns
    # First create a random walk
    random_walk = np.random.randn(length).cumsum() * 100

    # Add a trend
    trend = np.linspace(-500, 1000, length)

    # Add cycles
    cycles = 1000 * np.sin(np.linspace(0, 4*np.pi, length))

    # Combine them
    close_prices = base_price + random_walk + trend + cycles

    # Generate volatility
    volatility = np.random.rand(length) * 200 + 50  # 50-250 range

    # Generate high/low prices based on close and volatility
    high_prices = close_prices + volatility
    low_prices = close_prices - volatility

    # Generate open prices (previous close with some random adjustment)
    open_prices = np.concatenate([[close_prices[0]], close_prices[:-1]]) * (1 + np.random.randn(length) * 0.005)

    # Generate volume (higher volume during price movements)
    price_changes = np.abs(np.diff(np.concatenate([[0], close_prices])))
    volume = price_changes * np.random.rand(length) * 10 + 10

    # Create DataFrame
    df = pd.DataFrame({
        'timestamp': [int(d.timestamp() * 1000) for d in dates],
        'symbol': symbol,
        'open': open_prices,
        'high': high_prices,
        'low': low_prices,
        'close': close_prices,
        'volume': volume
    })

    return df


def plot_indicator_signals(data, indicator):
    """Plot price data with indicator signals."""
    # Calculate indicator values
    data_with_indicator = indicator.calculate(data.copy())

    # Generate signals for each candle
    signals = []
    signal_indices = []

    for i in range(len(data_with_indicator)):
        window = data_with_indicator.iloc[:i+1]
        signal = indicator.generate_signal(window)
        if signal:
            signals.append(signal.direction)
            signal_indices.append(i)

    # Create plot
    fig, ax = plt.subplots(figsize=(14, 7))

    # Plot price
    ax.plot(data["close"], label="Close Price")

    # Plot indicator lines if available
    if isinstance(indicator, MAIndicator):
        ax.plot(data_with_indicator["short_ma"], label=f"Short MA ({indicator.short_period})")
        ax.plot(data_with_indicator["long_ma"], label=f"Long MA ({indicator.long_period})")
    elif isinstance(indicator, RSIIndicator):
        ax2 = ax.twinx()
        ax2.plot(data_with_indicator["rsi"], label="RSI", color="purple", alpha=0.6)
        ax2.axhline(y=indicator.overbought, color='r', linestyle='--', alpha=0.3)
        ax2.axhline(y=indicator.oversold, color='g', linestyle='--', alpha=0.3)
        ax2.set_ylabel('RSI')
        ax2.set_ylim(0, 100)
        ax2.grid(False)
        ax2.legend(loc="upper right")

    # Plot buy and sell signals
    buy_indices = [idx for i, idx in enumerate(signal_indices) if signals[i] == SignalDirection.BUY]
    sell_indices = [idx for i, idx in enumerate(signal_indices) if signals[i] == SignalDirection.SELL]

    if buy_indices:
        ax.scatter(
            buy_indices,
            data.iloc[buy_indices]["close"],
            marker="^",
            color="green",
            s=100,
            label="Buy Signal"
        )

    if sell_indices:
        ax.scatter(
            sell_indices,
            data.iloc[sell_indices]["close"],
            marker="v",
            color="red",
            s=100,
            label="Sell Signal"
        )

    # Customize plot
    ax.set_title(f"{indicator.name} Signals")
    ax.set_xlabel("Candle Number")
    ax.set_ylabel("Price")
    ax.legend(loc="upper left")
    ax.grid(True, alpha=0.3)

    return fig


def main():
    """Run the indicator demonstration."""
    # Setup directories
    results_dir = Path("../../../tests/__test_results__/indicator_demo")
    results_dir.mkdir(parents=True, exist_ok=True)

    # Create config file if it doesn't exist
    config_file = results_dir / "indicator_config_example.yaml"
    if not config_file.exists():
        # Example configs
        config_data = {
            "indicators": [
                {
                    "name": "ma_crossover_fast",
                    "type": "ma",
                    "enabled": True,
                    "parameters": {
                        "short_period": 5,
                        "long_period": 20,
                        "ma_type": "sma"
                    }
                },
                {
                    "name": "ma_crossover_medium",
                    "type": "ma",
                    "enabled": True,
                    "parameters": {
                        "short_period": 10,
                        "long_period": 30,
                        "ma_type": "sma"
                    }
                },
                {
                    "name": "ema_crossover",
                    "type": "ma",
                    "enabled": True,
                    "parameters": {
                        "short_period": 12,
                        "long_period": 26,
                        "ma_type": "ema"
                    }
                },
                {
                    "name": "rsi_standard",
                    "type": "rsi",
                    "enabled": True,
                    "parameters": {
                        "period": 14,
                        "overbought": 70,
                        "oversold": 30
                    }
                },
                {
                    "name": "rsi_sensitive",
                    "type": "rsi",
                    "enabled": True,
                    "parameters": {
                        "period": 9,
                        "overbought": 65,
                        "oversold": 35
                    }
                }
            ]
        }

        with open(config_file, "w") as f:
            yaml.dump(config_data, f, default_flow_style=False)

    # Generate sample data
    logger.info("Generating sample data...")
    data = generate_sample_data(length=200)

    # Load indicators from configuration file
    logger.info(f"Loading indicators from {config_file}...")
    indicators = IndicatorConfigLoader.load_indicators(config_file)

    if not indicators:
        logger.error("No indicators loaded from configuration file")
        return

    # Generate and save plots for each indicator
    logger.info(f"Testing {len(indicators)} indicators...")

    for name, indicator in indicators.items():
        logger.info(f"Processing indicator: {name}")

        # Plot indicator with signals
        fig = plot_indicator_signals(data, indicator)

        # Save plot
        plot_file = results_dir / f"{name}_signals.png"
        fig.savefig(plot_file)
        plt.close(fig)

        logger.info(f"Saved plot to {plot_file}")

    # Create HTML viewer if it doesn't exist
    html_file = results_dir / "view_plots.html"
    if not html_file.exists():
        create_html_viewer(results_dir, indicators)

    # Copy the config file to the demo directory for reference
    shutil.copy(config_file, results_dir / "indicator_config.yaml")

    logger.info("Demonstration completed!")
    logger.info(f"Results saved to {results_dir}")
    logger.info(f"View plots at {html_file}")


def create_html_viewer(results_dir, indicators):
    """Create a simple HTML page to view the indicator plots."""
    html_file = results_dir / "view_plots.html"

    html_content = """<!DOCTYPE html>
<html>
<head>
    <title>Indicator Plots</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2 {
            color: #333;
        }
        h1 {
            text-align: center;
        }
        .plots {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 20px;
        }
        .plot {
            border: 1px solid #ddd;
            padding: 10px;
            border-radius: 5px;
        }
        .plot h2 {
            margin-top: 0;
            color: #555;
        }
        img {
            width: 100%;
            height: auto;
            border: 1px solid #eee;
        }
        .footer {
            text-align: center;
            margin-top: 20px;
            color: #777;
        }
    </style>
</head>
<body>
    <h1>Indicator Signal Analysis</h1>

    <div class="plots">
"""

    # Add plots for each indicator
    for name, indicator in indicators.items():
        plot_file = f"{name}_signals.png"

        description = ""
        if isinstance(indicator, MAIndicator):
            ma_type = "Exponential" if indicator.ma_type == "ema" else "Simple"
            description = f"""
            <p>
                This plot shows the {ma_type} Moving Average Crossover indicator with:
                <ul>
                    <li>Short period: {indicator.short_period}</li>
                    <li>Long period: {indicator.long_period}</li>
                </ul>
                Buy signals (green triangles) are generated when the short MA crosses above the long MA (golden cross),
                and sell signals (red triangles) are generated when the short MA crosses below the long MA (death cross).
            </p>
            """
        elif isinstance(indicator, RSIIndicator):
            description = f"""
            <p>
                This plot shows the Relative Strength Index indicator with:
                <ul>
                    <li>Period: {indicator.period}</li>
                    <li>Overbought threshold: {indicator.overbought}</li>
                    <li>Oversold threshold: {indicator.oversold}</li>
                </ul>
                Buy signals (green triangles) are generated when RSI crosses above the oversold threshold ({indicator.oversold}),
                and sell signals (red triangles) are generated when RSI crosses below the overbought threshold ({indicator.overbought}).
            </p>
            """

        html_content += f"""
        <div class="plot">
            <h2>{name}</h2>
            <img src="{plot_file}" alt="{name} Signals">
            {description}
        </div>
        """

    html_content += """
    </div>

    <div class="footer">
        <p>Generated by Indicator Integration Framework Demo</p>
        <p><a href="README.md">View Documentation</a> | <a href="indicator_config.yaml">View Configuration</a></p>
    </div>
</body>
</html>
"""

    with open(html_file, "w") as f:
        f.write(html_content)


if __name__ == "__main__":
    main()
