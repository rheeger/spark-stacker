import logging
import time
from datetime import datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, patch

import numpy as np
import pandas as pd
import pytest
from app.core.trading_engine import TradingEngine
from app.indicators.base_indicator import Signal, SignalDirection
from app.indicators.macd_indicator import MACDIndicator
from app.indicators.rsi_indicator import RSIIndicator
from app.webhook.webhook_server import WebhookServer


# Fixture for the webhook server
@pytest.fixture
def webhook_server(trading_engine):
    """Create a webhook server instance for testing."""
    server = WebhookServer(host="localhost", port=5001)
    server.add_signal_handler(trading_engine.process_signal)
    return server


@pytest.fixture
def price_data():
    """Sample price data for testing."""
    return pd.DataFrame(
        {
            "open": [
                100,
                105,
                110,
                115,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                80,
                85,
                90,
            ],
            "high": [
                105,
                110,
                115,
                120,
                125,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                90,
                95,
            ],
            "low": [95, 100, 105, 110, 115, 110, 105, 100, 95, 90, 85, 80, 75, 80, 85],
            "close": [
                105,
                110,
                115,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                80,
                85,
                90,
                95,
            ],
            "volume": [1000] * 15,
        },
        index=pd.date_range(start="2023-01-01", periods=15, freq="D"),
    )


@pytest.mark.asyncio
async def test_indicator_signal_to_engine(
    price_data, mock_connector, mock_risk_manager, trading_engine
):
    """
    Test the flow from indicator signal generation to trading engine processing.

    This test verifies that signals generated by indicators are properly
    processed by the trading engine and result in the expected trade actions.
    """
    # Set up the mock connector
    mock_connector.get_ticker.return_value = {"symbol": "ETH", "last_price": 100.0}

    # Configure the mock risk manager
    mock_risk_manager.calculate_position_size.return_value = (
        1.0,
        5.0,
    )  # size, leverage
    mock_risk_manager.calculate_hedge_parameters.return_value = (
        0.2,
        2.0,
    )  # hedge size, hedge leverage
    mock_risk_manager.validate_trade.return_value = (True, "Trade validated")

    # Start the trading engine
    trading_engine.start()

    # Create an RSI indicator and process the price data
    rsi = RSIIndicator(
        name="RSI",
        params={"period": 5, "overbought": 70, "oversold": 30, "signal_period": 1},
    )

    # Process the price data and generate a signal
    processed_data, signal = rsi.process(price_data.copy())

    # Pass the signal to the trading engine if one was generated
    if signal:
        result = await trading_engine.process_signal(signal)
        assert result is True, "Signal processing should succeed"

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )
    else:
        # If no signal was generated, force a test signal to validate engine processing
        test_signal = Signal(
            direction=SignalDirection.BUY,
            symbol="ETH",
            indicator="RSI",
            confidence=0.8,
            timestamp=int(time.time() * 1000),
            params={"threshold": 30, "price": 100.0},
        )
        result = await trading_engine.process_signal(test_signal)
        assert result is True, "Signal processing should succeed"

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )

    # Stop the trading engine
    trading_engine.stop()


@pytest.mark.asyncio
async def test_macd_signal_to_engine(
    sample_price_data,
    mock_connector,
    mock_risk_manager,
    trading_engine
):
    """
    Test the flow from MACD indicator signal generation (MVP params) to trading engine processing.
    """
    logger = logging.getLogger(__name__)
    logger.info("Starting test_macd_signal_to_engine...")

    # --- Setup Mocks ---
    mock_connector.get_ticker.return_value = {"symbol": "ETH", "last_price": 100.0}
    mock_connector.place_order = AsyncMock(return_value={
        "status": "FILLED",
        "order_id": "mock_order_123",
        "symbol": "ETH",
        "side": "BUY",
        "size": 1.0,
        "price": 1500.0,
        "entry_price": 1500.0,
        "status": "FILLED",
        "leverage": 5.0,
        "position_id": "mock_position_1",
        "unrealized_pnl": 0.0,
        "liquidation_price": 0.0,
        "margin": 300.0,
        "timestamp": int(time.time() * 1000)
    })
    mock_connector.get_account_balance.return_value = {"PERP_USDC": 1000.0}
    mock_connector.get_markets.return_value = [{
        "symbol": "ETH", "base_asset": "ETH", "quote_asset": "USD", "price_precision": 2,
        "min_size": 0.01, "tick_size": "0.01", "market_type": "PERPETUAL", "active": True
    }]

    # Configure the mock risk manager to allow trades
    mock_risk_manager.calculate_position_size.return_value = (1.0, 5.0)
    mock_risk_manager.calculate_hedge_parameters.return_value = (0.2, 2.0)
    mock_risk_manager.validate_trade.return_value = (True, "Trade validated")

    # --- Initialize Indicator ---
    mvp_params = {
        "fast_period": 8,
        "slow_period": 21,
        "signal_period": 5,
    }
    macd_mvp = MACDIndicator(name="macd_mvp", params=mvp_params)
    logger.info(f"Initialized MACD indicator with params: {mvp_params}")

    # --- Process Data & Generate Signals ---
    df = sample_price_data.copy()
    logger.info(f"Processing sample price data with shape: {df.shape}")
    result_df = macd_mvp.generate_signals(df)
    signals = []
    for index, row in result_df.iterrows():
        if pd.notna(row["signal"]):
            signal_obj = Signal(
                direction=row["signal"],
                symbol=row.get("symbol", "ETH"),
                indicator=macd_mvp.name,
                confidence=row["confidence"],
                timestamp=int(index.timestamp() * 1000),
                params={
                    "macd": row["macd"],
                    "signal_line": row["macd_signal"],
                    "histogram": row["macd_histogram"],
                    "trigger": "crosses_above_signal" if row["signal"] == SignalDirection.BUY else "crosses_below_signal"
                }
            )
            signals.append(signal_obj)

    logger.info(f"Generated {len(signals)} signals from MACD indicator.")

    # --- Start Engine & Process Signals ---
    if not signals:
        pytest.skip("No MACD signals generated from sample data, skipping engine processing test.")

    try:
        # Make sure engine uses the mock connector
        trading_engine.main_connector = mock_connector
        trading_engine.hedge_connector = mock_connector
        trading_engine.risk_manager = mock_risk_manager
        trading_engine.dry_run = False

        # Ensure the engine is reset/clean before processing
        trading_engine.active_trades = {}
        trading_engine.trade_history = []

        # Start the trading engine (non-blocking if already designed that way)
        logger.info("Starting trading engine...")
        engine_started = trading_engine.start()
        assert engine_started is True, "Trading engine failed to start"
        logger.info("Trading engine started.")

        logger.info(f"Processing {len(signals)} signals...")
        first_signal_processed = False
        for signal in signals:
            logger.debug(f"Processing signal: {signal}")
            success = await trading_engine.process_signal(signal)
            logger.debug(f"Signal processing result: {success}")

            if not first_signal_processed:
                # First signal should succeed
                assert success is True, "First signal processing should succeed"
                first_signal_processed = True
            else:
                # Subsequent signals may fail due to max parallel trades limit
                if not success:
                    assert len(trading_engine.active_trades) >= trading_engine.max_parallel_trades, \
                        "Signal processing failure should only occur when max parallel trades is reached"

        # --- Assertions ---
        logger.info("Checking assertions...")
        assert mock_connector.place_order.called, "TradingEngine did not call place_order on the mock connector."
        assert len(trading_engine.active_trades) > 0, "No active trades after signal processing"

    finally:
        # Stop the engine
        logger.info("Stopping trading engine...")
        trading_engine.stop()
        logger.info("Trading engine stopped.")


def test_webhook_to_indicator_to_engine(
    trading_engine, webhook_server, mock_connector, mock_risk_manager
):
    """
    Test the complete flow from webhook to indicator to trading engine.

    This test verifies that signals received via webhook are properly processed
    by the indicator framework and result in the expected trade actions by the
    trading engine.
    """
    # Skip test if running in CI environment
    pytest.skip(
        "This test requires a running Flask server and is meant for local testing only"
    )

    # Set up the mocks
    mock_connector.get_ticker.return_value = {"symbol": "ETH", "last_price": 100.0}

    mock_risk_manager.calculate_position_size.return_value = (1.0, 5.0)
    mock_risk_manager.validate_trade.return_value = (True, "Trade validated")

    # Start the trading engine and webhook server
    trading_engine.start()
    webhook_server.start()

    try:
        # Wait for the server to start
        time.sleep(1)

        # Create a webhook payload (simulating TradingView)
        payload = {
            "passphrase": "test_passphrase",
            "strategy": {"direction": "buy", "market": "ETH", "position_size": 1.0},
            "ticker": "ETH",
            "bar": {
                "time": "2023-01-15T00:00:00Z",
                "open": 90.0,
                "high": 95.0,
                "low": 85.0,
                "close": 95.0,
                "volume": 1000,
            },
        }

        # Use requests to send the payload to the webhook
        import requests

        url = "http://localhost:5001/webhook/tradingview"
        response = requests.post(url, json=payload)

        # Check that the request was successful
        assert response.status_code == 200

        # Wait for the signal to be processed
        time.sleep(1)

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )

    finally:
        # Stop the webhook server and trading engine
        webhook_server.stop()
        trading_engine.stop()
