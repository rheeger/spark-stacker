import pytest
import pandas as pd
import numpy as np
import logging
import time
from datetime import datetime, timedelta
from unittest.mock import MagicMock, patch

from app.indicators.rsi_indicator import RSIIndicator
from app.core.trading_engine import TradingEngine
from app.indicators.base_indicator import Signal, SignalDirection
from app.webhook.webhook_server import WebhookServer


# Fixture for the webhook server
@pytest.fixture
def webhook_server(trading_engine):
    """Create a webhook server instance for testing."""
    server = WebhookServer(host="localhost", port=5001)
    server.add_signal_handler(trading_engine.process_signal)
    return server


@pytest.fixture
def price_data():
    """Sample price data for testing."""
    return pd.DataFrame(
        {
            "open": [
                100,
                105,
                110,
                115,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                80,
                85,
                90,
            ],
            "high": [
                105,
                110,
                115,
                120,
                125,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                90,
                95,
            ],
            "low": [95, 100, 105, 110, 115, 110, 105, 100, 95, 90, 85, 80, 75, 80, 85],
            "close": [
                105,
                110,
                115,
                120,
                115,
                110,
                105,
                100,
                95,
                90,
                85,
                80,
                85,
                90,
                95,
            ],
            "volume": [1000] * 15,
        },
        index=pd.date_range(start="2023-01-01", periods=15, freq="D"),
    )


def test_indicator_signal_to_engine(
    price_data, mock_connector, mock_risk_manager, trading_engine
):
    """
    Test the flow from indicator signal generation to trading engine processing.

    This test verifies that signals generated by indicators are properly
    processed by the trading engine and result in the expected trade actions.
    """
    # Set up the mock connector
    mock_connector.get_ticker.return_value = {"symbol": "ETH", "last_price": 100.0}

    # Configure the mock risk manager
    mock_risk_manager.calculate_position_size.return_value = (
        1.0,
        5.0,
    )  # size, leverage
    mock_risk_manager.calculate_hedge_parameters.return_value = (
        0.2,
        2.0,
    )  # hedge size, hedge leverage
    mock_risk_manager.validate_trade.return_value = (True, "Trade validated")

    # Start the trading engine
    trading_engine.start()

    # Create an RSI indicator and process the price data
    rsi = RSIIndicator(
        name="RSI",
        params={"period": 5, "overbought": 70, "oversold": 30, "signal_period": 1},
    )

    # Process the price data and generate a signal
    processed_data, signal = rsi.process(price_data.copy())

    # Pass the signal to the trading engine if one was generated
    if signal:
        trading_engine.process_signal(signal)

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )
    else:
        # If no signal was generated, force a test signal to validate engine processing
        test_signal = Signal(
            direction=SignalDirection.BUY,
            symbol="ETH",
            indicator="RSI",
            confidence=0.8,
            timestamp=int(time.time() * 1000),
            params={"threshold": 30, "price": 100.0},
        )
        trading_engine.process_signal(test_signal)

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )

    # Stop the trading engine
    trading_engine.stop()


def test_webhook_to_indicator_to_engine(
    trading_engine, webhook_server, mock_connector, mock_risk_manager
):
    """
    Test the complete flow from webhook to indicator to trading engine.

    This test verifies that signals received via webhook are properly processed
    by the indicator framework and result in the expected trade actions by the
    trading engine.
    """
    # Skip test if running in CI environment
    pytest.skip(
        "This test requires a running Flask server and is meant for local testing only"
    )

    # Set up the mocks
    mock_connector.get_ticker.return_value = {"symbol": "ETH", "last_price": 100.0}

    mock_risk_manager.calculate_position_size.return_value = (1.0, 5.0)
    mock_risk_manager.validate_trade.return_value = (True, "Trade validated")

    # Start the trading engine and webhook server
    trading_engine.start()
    webhook_server.start()

    try:
        # Wait for the server to start
        time.sleep(1)

        # Create a webhook payload (simulating TradingView)
        payload = {
            "passphrase": "test_passphrase",
            "strategy": {"direction": "buy", "market": "ETH", "position_size": 1.0},
            "ticker": "ETH",
            "bar": {
                "time": "2023-01-15T00:00:00Z",
                "open": 90.0,
                "high": 95.0,
                "low": 85.0,
                "close": 95.0,
                "volume": 1000,
            },
        }

        # Use requests to send the payload to the webhook
        import requests

        url = "http://localhost:5001/webhook/tradingview"
        response = requests.post(url, json=payload)

        # Check that the request was successful
        assert response.status_code == 200

        # Wait for the signal to be processed
        time.sleep(1)

        # Check that the trading engine processed the signal
        assert (
            len(trading_engine.active_trades) > 0
            or len(trading_engine.get_trade_history()) > 0
        )

    finally:
        # Stop the webhook server and trading engine
        webhook_server.stop()
        trading_engine.stop()
